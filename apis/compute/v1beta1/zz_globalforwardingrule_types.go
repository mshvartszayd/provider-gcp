/*
Copyright 2021 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type FilterLabelsObservation struct {
}

type FilterLabelsParameters struct {

	// Name of the resource; provided by the client when the resource is
	// created. The name must be 1-63 characters long, and comply with
	// RFC1035. Specifically, the name must be 1-63 characters long and match
	// the regular expression [a-z]([-a-z0-9]*[a-z0-9])? which means the
	// first character must be a lowercase letter, and all following
	// characters must be a dash, lowercase letter, or digit, except the last
	// character, which cannot be a dash.
	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// The value that the label must match. The value has a maximum
	// length of 1024 characters.
	// +kubebuilder:validation:Required
	Value *string `json:"value" tf:"value,omitempty"`
}

type GlobalForwardingRuleObservation struct {

	// an identifier for the resource with format projects/{{project}}/global/forwardingRules/{{name}}
	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// (Beta)
	// The fingerprint used for optimistic locking of this resource.  Used
	// internally during updates.
	LabelFingerprint *string `json:"labelFingerprint,omitempty" tf:"label_fingerprint,omitempty"`

	// an identifier for the resource with format projects/{{project}}/global/forwardingRules/{{name}}
	PscConnectionID *string `json:"pscConnectionId,omitempty" tf:"psc_connection_id,omitempty"`

	PscConnectionStatus *string `json:"pscConnectionStatus,omitempty" tf:"psc_connection_status,omitempty"`

	// The URI of the created resource.
	SelfLink *string `json:"selfLink,omitempty" tf:"self_link,omitempty"`
}

type GlobalForwardingRuleParameters struct {

	// An optional description of this resource. Provide this property when
	// you create the resource.
	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// The IP address that this forwarding rule serves. When a client sends
	// traffic to this IP address, the forwarding rule directs the traffic to
	// the target that you specify in the forwarding rule. The
	// loadBalancingScheme and the forwarding rule's target determine the
	// type of IP address that you can use. For detailed information, refer
	// to IP address specifications.
	// An address can be specified either by a literal IP address or a
	// reference to an existing Address resource. If you don't specify a
	// reserved IP address, an ephemeral IP address is assigned.
	// The value must be set to 0.0.0.0 when the target is a targetGrpcProxy
	// that has validateForProxyless field set to true.
	// For Private Service Connect forwarding rules that forward traffic to
	// Google APIs, IP address must be provided.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.GlobalAddress
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	IPAddress *string `json:"ipAddress,omitempty" tf:"ip_address,omitempty"`

	// Reference to a GlobalAddress in compute to populate ipAddress.
	// +kubebuilder:validation:Optional
	IPAddressRef *v1.Reference `json:"ipAddressRef,omitempty" tf:"-"`

	// Selector for a GlobalAddress in compute to populate ipAddress.
	// +kubebuilder:validation:Optional
	IPAddressSelector *v1.Selector `json:"ipAddressSelector,omitempty" tf:"-"`

	// The IP protocol to which this rule applies. When the load balancing scheme is
	// INTERNAL_SELF_MANAGED, only TCP is valid. This field must not be set if the
	// global address is configured as a purpose of PRIVATE_SERVICE_CONNECT
	// and addressType of INTERNAL
	// Possible values are TCP, UDP, ESP, AH, SCTP, and ICMP.
	// +kubebuilder:validation:Optional
	IPProtocol *string `json:"ipProtocol,omitempty" tf:"ip_protocol,omitempty"`

	// The IP Version that will be used by this global forwarding rule.
	// Possible values are IPV4 and IPV6.
	// +kubebuilder:validation:Optional
	IPVersion *string `json:"ipVersion,omitempty" tf:"ip_version,omitempty"`

	// Labels to apply to this forwarding rule.  A list of key->value pairs.
	// +kubebuilder:validation:Optional
	Labels map[string]*string `json:"labels,omitempty" tf:"labels,omitempty"`

	// This signifies what the GlobalForwardingRule will be used for.
	// The value of INTERNAL_SELF_MANAGED means that this will be used for
	// Internal Global HTTP(S) LB. The value of EXTERNAL means that this
	// will be used for External Global Load Balancing (HTTP(S) LB,
	// External TCP/UDP LB, SSL Proxy). The value of EXTERNAL_MANAGED means
	// that this will be used for Global external HTTP(S) load balancers.
	// (Beta only) Note: This field must be set "" if the global address is
	// configured as a purpose of PRIVATE_SERVICE_CONNECT and addressType of INTERNAL.
	// Default value is EXTERNAL.
	// Possible values are EXTERNAL, EXTERNAL_MANAGED, and INTERNAL_SELF_MANAGED.
	// +kubebuilder:validation:Optional
	LoadBalancingScheme *string `json:"loadBalancingScheme,omitempty" tf:"load_balancing_scheme,omitempty"`

	// Opaque filter criteria used by Loadbalancer to restrict routing
	// configuration to a limited set xDS compliant clients. In their xDS
	// requests to Loadbalancer, xDS clients present node metadata. If a
	// match takes place, the relevant routing configuration is made available
	// to those proxies.
	// For each metadataFilter in this list, if its filterMatchCriteria is set
	// to MATCH_ANY, at least one of the filterLabels must match the
	// corresponding label provided in the metadata. If its filterMatchCriteria
	// is set to MATCH_ALL, then all of its filterLabels must match with
	// corresponding labels in the provided metadata.
	// metadataFilters specified here can be overridden by those specified in
	// the UrlMap that this ForwardingRule references.
	// metadataFilters only applies to Loadbalancers that have their
	// loadBalancingScheme set to INTERNAL_SELF_MANAGED.
	// Structure is documented below.
	// +kubebuilder:validation:Optional
	MetadataFilters []MetadataFiltersParameters `json:"metadataFilters,omitempty" tf:"metadata_filters,omitempty"`

	// This field is not used for external load balancing.
	// For INTERNAL_SELF_MANAGED load balancing, this field
	// identifies the network that the load balanced IP should belong to
	// for this global forwarding rule. If this field is not specified,
	// the default network will be used.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.Network
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	Network *string `json:"network,omitempty" tf:"network,omitempty"`

	// Reference to a Network in compute to populate network.
	// +kubebuilder:validation:Optional
	NetworkRef *v1.Reference `json:"networkRef,omitempty" tf:"-"`

	// Selector for a Network in compute to populate network.
	// +kubebuilder:validation:Optional
	NetworkSelector *v1.Selector `json:"networkSelector,omitempty" tf:"-"`

	// This field is used along with the target field for TargetHttpProxy,
	// TargetHttpsProxy, TargetSslProxy, TargetTcpProxy, TargetVpnGateway,
	// TargetPool, TargetInstance.
	// Applicable only when IPProtocol is TCP, UDP, or SCTP, only packets
	// addressed to ports in the specified range will be forwarded to target.
	// Forwarding rules with the same [IPAddress, IPProtocol] pair must have
	// disjoint port ranges.
	// Some types of forwarding target have constraints on the acceptable
	// ports:
	// +kubebuilder:validation:Optional
	PortRange *string `json:"portRange,omitempty" tf:"port_range,omitempty"`

	// The ID of the project in which the resource belongs.
	// If it is not provided, the provider project is used.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.Network
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractParamPath("project",false)
	// +kubebuilder:validation:Optional
	Project *string `json:"project,omitempty" tf:"project,omitempty"`

	// Reference to a Network in compute to populate project.
	// +kubebuilder:validation:Optional
	ProjectRef *v1.Reference `json:"projectRef,omitempty" tf:"-"`

	// Selector for a Network in compute to populate project.
	// +kubebuilder:validation:Optional
	ProjectSelector *v1.Selector `json:"projectSelector,omitempty" tf:"-"`

	// The URL of the target resource to receive the matched traffic.
	// The forwarded traffic must be of a type appropriate to the target object.
	// For INTERNAL_SELF_MANAGED load balancing, only HTTP and HTTPS targets
	// are valid.
	// (Beta only) For global address with a purpose of PRIVATE_SERVICE_CONNECT and
	// addressType of INTERNAL, only "all-apis" and "vpc-sc" are valid.
	// +crossplane:generate:reference:type=github.com/upbound/provider-gcp/apis/compute/v1beta1.TargetSSLProxy
	// +crossplane:generate:reference:extractor=github.com/upbound/upjet/pkg/resource.ExtractResourceID()
	// +kubebuilder:validation:Optional
	Target *string `json:"target,omitempty" tf:"target,omitempty"`

	// Reference to a TargetSSLProxy in compute to populate target.
	// +kubebuilder:validation:Optional
	TargetRef *v1.Reference `json:"targetRef,omitempty" tf:"-"`

	// Selector for a TargetSSLProxy in compute to populate target.
	// +kubebuilder:validation:Optional
	TargetSelector *v1.Selector `json:"targetSelector,omitempty" tf:"-"`
}

type MetadataFiltersObservation struct {
}

type MetadataFiltersParameters struct {

	// The list of label value pairs that must match labels in the
	// provided metadata based on filterMatchCriteria
	// This list must not be empty and can have at the most 64 entries.
	// Structure is documented below.
	// +kubebuilder:validation:Required
	FilterLabels []FilterLabelsParameters `json:"filterLabels" tf:"filter_labels,omitempty"`

	// Specifies how individual filterLabel matches within the list of
	// filterLabels contribute towards the overall metadataFilter match.
	// MATCH_ANY - At least one of the filterLabels must have a matching
	// label in the provided metadata.
	// MATCH_ALL - All filterLabels must have matching labels in the
	// provided metadata.
	// Possible values are MATCH_ANY and MATCH_ALL.
	// +kubebuilder:validation:Required
	FilterMatchCriteria *string `json:"filterMatchCriteria" tf:"filter_match_criteria,omitempty"`
}

// GlobalForwardingRuleSpec defines the desired state of GlobalForwardingRule
type GlobalForwardingRuleSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     GlobalForwardingRuleParameters `json:"forProvider"`
}

// GlobalForwardingRuleStatus defines the observed state of GlobalForwardingRule.
type GlobalForwardingRuleStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        GlobalForwardingRuleObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// GlobalForwardingRule is the Schema for the GlobalForwardingRules API. Represents a GlobalForwardingRule resource.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,gcp}
type GlobalForwardingRule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              GlobalForwardingRuleSpec   `json:"spec"`
	Status            GlobalForwardingRuleStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// GlobalForwardingRuleList contains a list of GlobalForwardingRules
type GlobalForwardingRuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []GlobalForwardingRule `json:"items"`
}

// Repository type metadata.
var (
	GlobalForwardingRule_Kind             = "GlobalForwardingRule"
	GlobalForwardingRule_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: GlobalForwardingRule_Kind}.String()
	GlobalForwardingRule_KindAPIVersion   = GlobalForwardingRule_Kind + "." + CRDGroupVersion.String()
	GlobalForwardingRule_GroupVersionKind = CRDGroupVersion.WithKind(GlobalForwardingRule_Kind)
)

func init() {
	SchemeBuilder.Register(&GlobalForwardingRule{}, &GlobalForwardingRuleList{})
}
